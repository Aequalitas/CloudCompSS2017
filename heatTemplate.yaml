heat_template_version: 2016-04-08
#The value of heat_template_version tells HEAT not only the format of the template but also features that will be validated and supported
#2016-04-08 represents the Mitaka release

#this section (parameters) allows the specification of input parameters (with default values)
parameters:
  #network parameters (neutron)
  public_network:
    type: string
    label: public network
    description: public network (id or name) that is used as external network
    default: f4f8b2e9-520a-481c-a1e3-bc1d8015d35b

  dns_nameserver:
    type: comma_delimited_list
    label: dns nameserver
    description: ip addresses of dns servers that are used for neutron subnet creation
    default: 8.8.8.8

  #compute parameters (nova)
  ssh_key_name:
    type: string
    label: ssh key name
    description: name of an existing ssh keypair that is injected during instance initialization
    default: weidmann
    hidden: false
    constraints:
      - custom_constraint: nova.keypair

  image_id:
    type: string
    label: image id
    description: image id that is used for instance creation
    default: fb8d8ef9-6274-4279-b3ee-525bd7fecfac #VMDK Ubuntu 14.04
    hidden: false
    constraints:
      - custom_constraint: glance.image

  instance_flavor:
    type: string
    label: instance flavor that is used for instance creation
    description: flavor used for instances
    default: m1.small
    hidden: false
    constraints:
      - custom_constraint: nova.flavor

  server_name:
    type: string
    label: server name
    description: name of the instances
    hidden: false
    default: webServer

  haProxy_name:
    type: string
    label: haProxy name
    description: name of the haProxy instance
    hidden: false
    default: haProxy

  username:
    type: string
    label: username
    description: username of the additional user
    hidden: false
    default: webserver

  gecos:
    type: string
    label: users full name
    description: full name of the additional user
    hidden: false
    default: webserver

  user_key:
    type: string
    label: users public key
    description: public key of the additional user that is injected during instance initialization
    hidden: false
    default: AAAAB3NzaC1yc2EAAAADAQABAAABAQCIUtMQiX7D+G3Zob6VreTz3lgODT2DQUtY9C84RZ2ctTAxMQr8Thfb5p/yDLnmGurRwTS9E6/wADNXTFaLdPouq9aRSBDqbw7Ob+c6bLUSNT1S+CpY38Aw0gDPimFYLdgBsOpSd9gIJyD+GIMbXfHDhlFsO0NvDk+gIS+65FsLl+5S/iiAMSyxX9hu3XQrw24kWkGn4pFrYrkMB2zU60jL1RcjD4nqlqd5KUgbSFXLLWhGo3n27HVjfKz2cpqcjZ6DnAyAaImERlBlSc62ShYHfnko3liNV3e+SOf8imS94P5vgZ3hn8YDS7P/P6TgSk3sEScPwmrq4tQ3fH+fPgdV

#this section (resources) allows the definition of openstack resources that are deployed as a heat stack
resources:
  #network resources
  #create a neutron network
  private_network:
    type: OS::Neutron::Net
    properties:
      name: private_network

  #create a neutron private subnet
  private_network_subnet:
    type: OS::Neutron::Subnet
    properties:
      cidr: 192.168.0.0/24
      gateway_ip: 192.168.0.1
      allocation_pools: [{ "start": 192.168.0.10, "end": 192.168.0.200 }]
      network: { get_resource: private_network }
      name: private_network_subnet
      dns_nameservers: { get_param: dns_nameserver }
      enable_dhcp: true

  #create a neutron router and connect it to the external network
  router:
    type: OS::Neutron::Router
    properties:
      name: router
      external_gateway_info:
        network: { get_param: public_network }

  #connect the neutron router to the neutron private subnet
  router_interface:
    type: OS::Neutron::RouterInterface
    properties:
      router: { get_resource: router }
      subnet: { get_resource: private_network_subnet }

  #create a neutron security group for server access (allowing ssh and http)
  webserver_SG:
    type: OS::Neutron::SecurityGroup
    properties:
      description: specific security group
      name: webserver_SG
      rules:
        - protocol: tcp
          port_range_min: 22
          port_range_max: 22
        - protocol: tcp
          port_range_min: 80
          port_range_max: 80
        - protocol: tcp
          port_range_min: 8080
          port_range_max: 8080

     #create a neutron floating ip (external ip address)
  floating_ip:
    type: OS::Neutron::FloatingIP
    properties:
      floating_network: { get_param: public_network }

  #associate the neutron floating ip with the nova instance (webserver)
  floating_ip_association:
    type: OS::Neutron::FloatingIPAssociation
    properties:
      floatingip_id: { get_resource: floating_ip }
      port_id: { get_attr: [haProxy, addresses, { get_resource: private_network }, 0, port] }


  #compute resources
  #cloud-init (cloud config) for instance initialization/customization of the webservers
  webServer_cloud_config:
    type: OS::Heat::CloudConfig
    properties:
      cloud_config:
        users:
        - default
        - name: { get_param: username }
          gecos: { get_param: gecos }
          groups: sudo
          lock-passwd: false
          plain-text-passwd: webserver
          shell: /bin/bash
          sudo: ALL=(ALL) NOPASSWD:ALL
          ssh-authorized-keys:
          - { get_param: user_key }
        package_update: true
        package_upgrade: true
        packages:
        - python
        write_files:
        - path: /tmp/python/templates/index.html
          content: |
                <!DOCTYPE html>
                <html>
                    <body>
                        <title> Plant Classification App</title>
                        <h2>Plant Classification App</h2>
                        {% if cp %}
                        <h3>{{cp}}!</h3>
                        {% endif %}
                        <form action="/" method="POST" enctype=multipart/form-data>
                            <input name="file" type=file>
                            <input type="submit" value="Predict">
                        </form>
                        <!-- <script src='{{ url_for("static", filename="index.js") }}'></script> -->
                    </body>
                </html>
        - path: /tmp/python/serv.py
          content: |
                    import gzip
                    import urllib2
                    import pickle as p
                    import calcPlant as cP
                    from flask import Flask as f, request as req, render_template as rT

                    app = f(__name__)

                    PLANTS = ["Acer_Campestre", "Ilex_Aquifolium", "Quercus_Ilex", "Acer_Capillipes",	
                    "Ilex_Cornuta"	,	   "Quercus_Imbricaria",
                    "Acer_Circinatum",	"Liquidambar_Styraciflua", "Quercus_Infectoria_sub",
                    "Acer_Mono", "Liriodendron_Tulipifera", "Quercus_Kewensis",
                    "Acer_Opalus", "Lithocarpus_Cleistocarpus", "Quercus_Nigra",
                    "Acer_Palmatum", "Lithocarpus_Edulis", "Quercus_Palustris",
                    "Acer_Pictum", "Magnolia_Heptapeta", "Quercus_Phellos",
                    "Acer_Platanoids",		"Magnolia_Salicifolia",	   "Quercus_Phillyraeoides",
                    "Acer_Rubrum",		"Morus_Nigra",		   "Quercus_Pontica",
                    "Acer_Rufinerve",		"Olea_Europaea"	,	   "Quercus_Pubescens",
                    "Acer_Saccharinum",	"Phildelphus"		,   "Quercus_Pyrenaica",
                    "Alnus_Cordata"	,	"Quercus_Rhysophylla",
                    "Alnus_Maximowiczii",	"populus_adenopoda"	,   "Quercus_Rubra",
                    "Alnus_Rubra"	,	"populus_grandidentata"	,   "quercus_semecarpifolia",
                    "Alnus_Sieboldiana",	"Populus_Nigra"	,	   "Quercus_Shumardii",
                    "Alnus_Viridis"	,	"Prunus_Avium"	,	   "Quercus_Suber",
                    "arundinaria_simonii",	"Prunus_X_Shmittii"	  , "Quercus_Texana",
                    "Betula_Austrosinensis"	,"Pterocarya_Stenoptera",	   "quercus_trojana",
                    "Betula_Pendula"	,	"quercus_afares"	,	   "quercus_variabilis",
                    "callicarpa_bodinieri",	"Quercus_Agrifolia"	  , "Quercus_Vulcanica",
                    "Castanea_Sativa"	,	"quercus_alnifolia",	   "Quercus_x_Hispanica",
                    "celtis_koraiensis",	"Quercus_Brantii"		,   "quercus_x_turneri",
                    "cercis_siliquastrum",	"Quercus_Canariensis",	   "Rhododendron_x_Russellianum",
                    "Cornus_Chinensis",	"Quercus_Castaneifolia"	 ,  "salix_fragilis",
                    "cornus_controversa",	"quercus_cerris"	,	   "Salix_Intergra",
                    "Cornus_Macrophylla",	"quercus_chrysolepis",	   "sorbus_aria",
                    "cotinus_coggygria",	"Quercus_Coccifera"	  , "Tilia_Oliveri",
                    "crataegus_monogyna",	"quercus_coccinea",	   "Tilia_Platyphyllos",
                    "Cytisus_Battandieri"	,"quercus_crassifolia"	,   "tilia_tomentosa",
                    "Eucalyptus_Glaucescens",	"Quercus_Crassipes"	 ,  "Ulmus_Bergmanniana",
                    "eucalyptus_neglecta"	,"quercus_dolicholepis"	 ,  "Viburnum_Tinus",
                    "Eucalyptus_Urnigera"	,"Quercus_Ellipsoidalis"	,   "viburnum_x_rhytidophylloides",
                    "Fagus_Sylvatica"		,"Quercus_Greggii"	,	   "Zelkova_Serrata",
                    "ginkgo_biloba"		,"quercus_hartwissiana"
                    ]

                    @app.route("/")
                    def mainPage():
                            return rT("index.html")

                    @app.route("/", methods=["POST"])
                    def calcPlant():
                            msg = None

                            if 'file' in req.files:
                                file = req.files['file']
                                if file.filename != '':
                                    msg = "This leaf belongs to the %s" % PLANTS[cP.calcPlant(MODEL, file)]
                                else:
                                    msg = "No file selected"
                            else:
                                msg = "No file part"

                            return rT("index.html", cp=msg)


                    print "Server started..."

                    # fetch trained model once
                    def fetchModel():
                        response = urllib2.urlopen('https://github.com/Aequalitas/CloudCompSS2017/blob/master/plantsModel.p.gz?raw=true/')
                        gzipFile = open("modelTmp.gzip", "w")
                        gzipFile.write(response.read())

                        with gzip.open("modelTmp.gzip", "rb") as pl:
                            gzipFile.close()
                            f = open("modelTmp.txt", "w")
                            f.write(pl.read())
                            f.close()
                            return p.load(open("modelTmp.txt", "rb"))


                    # trained model
                    MODEL = fetchModel()

        - path: /tmp/python/calcPlant.py
          content: |
                    import cv2
                    import numpy as n

                    X_SIZE = 160
                    Y_SIZE = 189

                    # Predicts plant associated with the given image
                    def calcPlant(model, image):
                        pred = model.predict(prepareImg(image))
                        print pred
                        return pred[0]

                    def prepareImg(image):

                        prepImage = n.zeros(shape=(X_SIZE * Y_SIZE,))
                        img = cv2.imdecode(n.fromstring(image.read(), n.uint8), cv2.IMREAD_UNCHANGED)
                        res = cv2.resize(img, (Y_SIZE, X_SIZE), interpolation = cv2.INTER_CUBIC)

                        resC = 0
                        for a in range(0, X_SIZE):
                                for b in range(0, Y_SIZE):

                                    print res[a][b]       
                                    if res[a][b] == 255:
                                        prepImage[resC] = 1
                                    else:
                                        prepImage[resC] = 0
                                    
                                    resC += 1

                        return prepImage
        # install all needed parts for the webserver lib flask and start the webserver
        runcmd:
        - wget https://bootstrap.pypa.io/get-pip.py #apt-get install pip version 1.5.4 (too old for opencv)
        - sudo python get-pip.py
        - pip install setuptools
        - pip install flask
        - pip install opencv-python
        - pip install scikit-learn # for pickle and the serialized model
        - pip install scipy # for pickle and the serialized model
        - curl 192.168.0.4:8080/update/1/1 # register this machine at the haproxy
        - cd /tmp/
        - mkdir python
        - cd python
        - sudo FLASK_APP=serv.py flask run -h $(hostname -I) -p 80
        
        
  #compute resources
  #cloud-init (cloud config) for instance initialization/customization of the haProxy server
  haProxy_cloud_config:
    type: OS::Heat::CloudConfig
    properties:
      cloud_config:
        users:
        - default
        - name: { get_param: username }
          gecos: { get_param: gecos }
          groups: sudo
          lock-passwd: false
          plain-text-passwd: haProxy
          shell: /bin/bash
          sudo: ALL=(ALL) NOPASSWD:ALL
          ssh-authorized-keys:
          - { get_param: user_key }
        package_update: true
        package_upgrade: true
        packages:
        - python
        - python-pip
        - haproxy
        write_files:
        - path: /etc/haproxy/haproxy.cfg
          content: |
                global
                    maxconn 2000
                    user haproxy
                    group haproxy
                    
                defaults
                    log     global
                    mode    http
                    option  httplog
                    option  dontlognull
                    retries 3
                    option redispatch
                    timeout connect  5000
                    timeout client  10000
                    timeout server  10000
                    
                listen haproxy   
                    mode http
                    bind *:80
                    balance roundrobin
                    option httpclose
                    option forwardfor
        - path: /tmp/python/confServ.py
          content: |
                import subprocess as sp
                from flask import Flask as f
                from flask import request as req
                app = f(__name__)

                HAPATH = "/etc/haproxy/haproxy.cfg"

                @app.route("/")
                def hello():
                    return "Hello %s" % req.remote_addr

                @app.route("/update/<int:type>/<int:serverNR>")
                def updateHAProxy(type, serverNR):
                    ip = req.remote_addr
                    name = "webserver%d" % serverNR

                    if(type == 1):
                        cmd = 'printf "    server %s %s:80 check\n" >> %s' % (name, ip, HAPATH)
                    else:
                        pattern = "server %s %s:80 check" % (name, ip)
                        cmd = "sed -i '/%s/d' %s" % (pattern, HAPATH)

                    sp.call(cmd, shell=True)
                    sp.call("service haproxy reload", shell=True)
                    return "OK"
        
        runcmd:
        - sed -i "s/net.ipv4.ip_nonlocal_bind=0/net.ipv4.ip_nonlocal_bind=1/g" /etc/sysctl.conf
        - sed -i "s/ENABLED=0/ENABLED=1/g" /etc/default/haproxy
        - pip install setuptools
        - pip install flask 
        - cd /tmp/
        - mkdir python
        - cd python
        - FLASK_APP=confServ.py flask run -h $(hostname -I) -p 8080
        - service haproxy start

  haProxyPort:
    type: OS::Neutron::Port
    properties:
        name: "haProxyIntern"
        network: {get_resource: private_network}
        fixed_ips: [{"ip_address":192.168.0.4, "subnet": {get_resource: private_network_subnet}}]
  
  haProxy:
    type: OS::Nova::Server
    properties:
      name: { get_param: haProxy_name }
      image: { get_param: image_id }
      flavor: { get_param: instance_flavor }
      key_name: { get_param: ssh_key_name }
      networks:
      #- network: { get_resource: private_network }
      - port : { get_resource: haProxyPort}
      security_groups:
      - { get_resource: webserver_SG }
      user_data_format: RAW
      user_data: { get_resource: haProxy_cloud_config }

  #auto scaling for the webservers
  #create a heat auto scaling group for the nova instances
  web_autoscale_group:
    type: OS::Heat::AutoScalingGroup
    properties:
      desired_capacity: 2
      min_size: 2
      max_size: 5
      resource:
        type: OS::Nova::Server
        properties:
         name: { get_param: server_name }
         image: { get_param: image_id }
         flavor: { get_param: instance_flavor }
         key_name: { get_param: ssh_key_name }
         networks:
           - network: { get_resource: private_network }
         security_groups:
           - { get_resource: webserver_SG }
         metadata: {"metering.autoscale_group_name": "web_autoscale_group"}
         user_data_format: RAW
         user_data: { get_resource: webServer_cloud_config }

  #create a heat scaling policy for the scale out regarding the auto scaling group for the nova instances
  web_scaleout_policy:
    type: OS::Heat::ScalingPolicy
    properties:
      adjustment_type: change_in_capacity
      auto_scaling_group_id: { get_resource: web_autoscale_group }
      cooldown: 60
      scaling_adjustment: 1

  #create a heat scaling policy for the scale in regarding the auto scaling group for the nova instances
  web_scalein_policy:
    type: OS::Heat::ScalingPolicy
    properties:
      adjustment_type: change_in_capacity
      auto_scaling_group_id: { get_resource: web_autoscale_group }
      cooldown: 60
      scaling_adjustment: -1

  #create a ceilometer alarm that indicates heat to scale out regarding the auto scaling group for the nova instances
  web_cpu_alarm_high:
    type: OS::Ceilometer::Alarm
    properties:
      meter_name: cpu_util
      statistic: avg
      period: 60
      evaluation_periods: 1
      threshold: 25
      repeat_actions: true
      alarm_actions:
        - {get_attr: [web_scaleout_policy, alarm_url]}
      matching_metadata: {'metadata.user_metadata.autoscale_group_name': "web_autoscale_group"}
      comparison_operator: gt

  #create a ceilometer alarm that indicates heat to scale in regarding the auto scaling group for the nova instances
  web_cpu_alarm_low:
    type: OS::Ceilometer::Alarm
    properties:
      meter_name: cpu_util
      statistic: avg
      period: 60
      evaluation_periods: 1
      threshold: 10
      repeat_actions: true
      alarm_actions:
        - {get_attr: [web_scalein_policy, alarm_url]}
      matching_metadata: {'metadata.user_metadata.autoscale_group_name': "web_autoscale_group"}
      comparison_operator: lt

